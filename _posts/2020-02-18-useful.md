---
layout: post-for-algorithm
title:  "Application of some algorithm or usefull command"
date:   2020-02-19 13:14:56 +0800
excerpt: ""
algorithm: true
---

# Jupyter

## 快捷键：

### 批量注释

* 在Jupyter Notebook中批量注释多行，在前面加上`#`

	* 全选
	* `ctrl` + `/`

* 删除以上注释：
	* 同上


### 缩进

* 缩进`ctrl`+`]`
* 解除 缩进`ctrl`+`[`

# 排序

* 比如现在有两个序列`serial`和`tstamp`是一一对应的，我们的目的是对两者根据其中一个序列进行排序
* 例如根据对时间戳`tstamp`按照时间序列`serial`的大小进行排序：

```python
r_serial	= sorted(serial) # from the minimun to maximun
r_tstamp	= [x for _, x in sorted(zip(serial,tstamp), key=lambda pair: pair[0])]
```

这个例子的目的是**活用lambda** 


# 查找

* 比如在一个序列中我们需要查找一个数或者字符的位置
* 有两种方法：
* 第一种就是采用`index`
* __仅仅针对`list`的sequence__ 

```python
>>> a = [1,2,3,4,5,6,7]
>>> a.index(3)
2
```

* 第二种就是我早年不懂事，走了很多弯路，采用的是

```python
>>> import numpy as np
>>> a = np.array([1,2,3,4,5,6,7])
>>> np.argmin(abs(a - 3))
2
>>> np.where(a==3)
(array([2]),)
>>> a = np.array([[1,2,3,4,5,6,7],[7,6,5,4,3,2,1]])
>>> np.where(a==3)
(array([0, 1]), array([2, 4]))
```


# 统计个数

主要有四种方法：根据[come&](https://blog.csdn.net/sinat_24091225/article/details/77925473)整理的结果：

1. 利用字典dict来完成统计

```python
a = [1, 2, 3, 1, 1, 2]
dict = {}
for key in a:
    dict[key] = dict.get(key, 0) + 1
print dict
```

输出结果：

```python
>>>{1: 3, 2: 2, 3: 1}
```

2. 利用Python的collection包下Counter的类

```python
from collections import Counter
a = [1, 2, 3, 1, 1, 2]
result = Counter(a)
print result
```
输出结果：

```python
>>>{1: 3, 2: 2, 3: 1}
```
3. Python的pandas包下的value_counts方法

```python
import pandas as pd
a = [1, 2, 3, 1, 1, 2]
result = pd.value_counts(a)
print result
```
输出结果：

```python
>>>1    3
   2    2
   3    1
```

注：利用pandas下的value_counts()，不仅可以统计list中各个元素出现的个数，还可对矩阵中的元素进行进行统计。 

```python
import pandas as pd
a = pd.DataFrame([[1,2,3],
                  [3,1,3],
                  [1,2,1]])
result = a.apply(pd.value_counts)
print result
```

输出结果：

```python
$ 2.0  1.0  1.0  # 表示元素1在第一列出现2次，在第二列出现1次，在第三列出现1次
$ NaN  2.0  NaN  # 表示元素2在第一列出现0次，在第二列出现2次，在第三列出现0次
$ 1.0  NaN  2.0  # 表示元素3在第一列出现1次，在第二列出现0次，在第三列出现2次
```

4. 如果是列表`list`

```python
>>> a = [1,2,3,4,5,6,7]
>>> a.count(1)
1
# 仅仅针对列表
>>> import numpy as np
>>> a = np.array([1,2,3,4,5,6,7])
>>> a.count(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'numpy.ndarray' object has no attribute 'count'
```

### 查看数据类型

有时候在编程的过程中会因为一些小错误花费大量时间，尤其是一些函数支持`int`,`float`,`double`，因此需要判断计算后会输出特定的类型

```
type(var).__name__
```

### 保存图片超过固定边界时：

```python

extent = ax4.get_window_extent().transformed(fig.dpi_scale_trans.inverted())
fig.savefig(path_data +'/' + title +'.pdf',fomat='pdf',bbox_inches=extent.expanded(2.2, 1.4))

```

YOU CAN CHANGE THE FORMAT `pdf` TO `png` et al.


### 数据内部同样的数字个数：

```python
sorted(X, key=X.__getitem__,reverse=True)
```

# LOGIN WITHOUT INTERP

```
ssh -o ServerAliveInterval=30 username@you.server.ip.address -L127.0.0.1:pre-setting-port:127.0.0.1:8889
```

对于我现在的电脑来说，由于一些原因，不能够修改屏幕保护程序，在安装了cygwin terminal 后，我在后面加入了
```bash
#!/bin/bash
x=1
while [ $x -le 5 ]
do
  sl
done
```

用以不停的开小火车，这样就可以达到显示屏不关。
但是大家还是让显示屏休息一下比较好。



# INSTALL STEAM ON FEDORA

```bash
sudo dnf install fedora-workstation-repositories
sudo dnf install -y steam --enablerepo=rpmfusion-nonfree-steam
```



### 如何在二维平面判断任意两条曲线相交？

* 首先假设两条曲线具有一一对应关系，比如
$$
y_1 = f_1(x_1)
\\
y_2 = f_2(x_2)
$$
	比如在地球物理学中，对应的台风（热带气旋、温带气旋、波破碎）路径往往是一个
	纬度值$latitude$对应一个经度$longitude$，几乎不存在不同时刻涡旋经纬度不变的情况
	也就是说可以对于路径来说可以近似表示为
$$
lat_1 = f_1(lon_1)
\\
lat_1 = f_1(lon_1)
$$

* 那么如何判断两个涡旋是否回相交？这里存在两种情况
	* 其中一个路线固定，比如台风与海岸线的关系
	* 另一种情况为两个台风相遇的问题

	无论何种情形，解决思路大致相同，框架上主要是`一重循环`套`判断`

* 首先设定判断两条曲线各个点比较的函数
	$$
	C=Sgn(f_1(x_1(t),t) - f_2(x_1(t),t))
	$$
	用来表示在某一个时刻，两条路径的中点的上下位置
	注意连个`x`采用的是同一个值。
	如果$C>0$那么$f_1$在$f_2$之上
	如果$C<0$那么$f_1$在$f_2$之下
* 这里比较的是两条曲线存在时间变化的情况，当其中一个是固定曲线，比如海岸线之于台风，那么就不存在变量`t`
* 最后这里仅仅比较是否相交，并不比较存在几个焦点的情况，那么在后面加个`break`用以节省计算资源


最后个人觉得这是个比较笨但是容易理解的方法，需要进一步提高计算能力


```python
# latsin and lonsin are baseline
# latsin_ and lonsin_ are the transform-line
var = []
y,x = (latsin[1:] - latsin[:-1])/2, (lonsin[1:] - lonsin[:-1])/2
a = y/x
b = y - a*x
y_, x_ = (latsin[1:] + latsin[:-1])/2, (lonsin[1:] + lonsin[:-1])/2
judge = y > (a*x_ + b)
if True in judge and False in judge
	var.append(lonsin,latsin)
```








### LaTex 命令总结

转自[樱花赞](https://www.cnblogs.com/1024th/)
[地址](https://www.cnblogs.com/1024th/p/11623258.html)



