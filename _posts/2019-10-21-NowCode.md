---
layout: post-for-algorithm
title:  "Algorithm in NowCode"
date:   2019-10-21 17:10:26 +0800
excerpt: "Basic algorithm in NowCode"
algorithm: true
---


# NowCode

## 字符

### 字符个数

* 题目描述

写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 

* 输入描述:

```
第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。
```

* 输出描述:

```
输出输入字符串中含有该字符的个数。
```

* 示例1

* 输入

```
ABCDEF
A
```

* 输出

```
1
```

```python
arr = input().upper()
a = input().upper()
s2=' '.join(arr)
print(s2.count(a))
```

### 数字颠倒

* 题目描述

描述： 

输入一个整数，将这个整数以字符串的形式逆序输出 

程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 

输入描述:

```
输入一个int整数
```

输出描述:

```
将这个整数以字符串的形式逆序输出
```

示例1

* 输入

```
1516000
```

* 输出

```
0006151
```

```python
print(str(input())[::-1])
```





### 字符逆序

* 题目描述

将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。 

如：输入“I am a student”，输出“tneduts a ma I”。  

输入参数：

inputString：输入的字符串
返回值：

输出转换好的逆序字符串

* 输入描述:

```
输入一个字符串，可以有空格
```

* 输出描述:

```
输出逆序的字符串
```

示例1

* 输入

```
I am a student
```

* 输出

```
tneduts a ma I
```

```python
print(input()[::-1])
```

### 句子逆序

* 题目描述

将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”
所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符


接口说明

/**
 * 反转句子
 * 
 * @param sentence 原句子
 * @return 反转后的句子
 */
public String reverse(String sentence); 

输入描述:

```
将一个英文语句以单词为单位逆序排放。
```

输出描述:

```
得到逆序的句子
```

示例1

* 输入

```
I am a boy
```

* 输出

```
boy a am I
```

```python
M = list(map(str,input().split(' ')))
print(' '.join(_ for _ in M[::-1]))
```

### 输入整型数组和排序标识，对其元素按照升序或降序进行排序

* 题目描述

输入整型数组和排序标识，对其元素按照升序或降序进行排序（一组测试用例可能会有多组数据）

接口说明

原型：

void sortIntegerArray(Integer[] pIntegerArray, int iSortFlag);

输入参数：

Integer[] pIntegerArray：整型数组

int  iSortFlag：排序标识：0表示按升序，1表示按降序

输出参数：

无

返回值：

void

* 输入描述:

```
1、输入需要输入的整型数个数
```

* 输出描述:

```
输出排好序的数字
```

示例1

* 输入

```
8
1 2 4 9 3 55 64 25
0
```

* 输出

```
1 2 3 4 9 25 55 64
```

```python
while True:
    try:
        N = int(input())
        M = list(map(int,input().split()))
        L = int(input())
        if L == 0:
            b = [str(i) for i in sorted(M)]
        else:
            b = [str(i) for i in sorted(M, reverse=True)]
        print(' '.join(b))
    except:
        break
```





### 字符串分割

* 题目描述

连续输入字符串(输出次数为N,字符串长度小于100)，请按长度为8拆分每个字符串后输出到新的字符串数组，

长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。

首先输入一个整数，为要输入的字符串个数。

* 例如：

输入：2

​      abc

​      12345789

输出：abc00000

​      12345678

​      90000000

接口函数设计如下:

/***************************************************************************** 
功能:存储输入的字符创

输入:字符串

输出:无 
     
返回:0表示成功,其它返回-1 
******************************************************************************/

int  AddString(char *strValue); 
/**************************************************************************** 
功能:获取补位后的二维数组的长度

输入:无

输出:无 
     
返回:二维数组长度 
*****************************************************************************/

int  GetLength();


/***************************************************************************** 
功能:将补位后的二维数组，与输入的二维数组做比较

输入:strInput:输入二维数组,iLen：输入的二维数组的长度

输出:无 
     
返回:若相等,返回0;不相等,返回-1.其它:-1; 
******************************************************************************/ 
int  ArrCmp(char strInput[][9],int iLen);

* 输入描述:

```
首先输入数字n，表示要输入多少个字符串。连续输入字符串(输出次数为N,字符串长度小于100)。
```

* 输出描述:

```
按长度为8拆分每个字符串后输出到新的字符串数组，长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。
```

示例1

* 输入

```
2
abc
123456789
```

* 输出

```
abc00000
12345678
90000000
```

```python
while True:
    try:
        N = int(input())
        for i in range(N):
            M = str(input())
            while len(M) > 8:
                print(M[:8])
                M = M[8:]
            print(M.ljust(8,'0'))
    except:
        break
```

### 字符个数统计

* 题目描述

编写一个函数，计算字符串中含有的不同字符的个数。字符在**ACSII**码范围内__(0~127)__。不在范围内的不作统计。

* 输入描述:

```
输入N个字符，字符在ACSII码范围内。
```

* 输出描述:

```
输出范围在(0~127)字符的个数。
```

示例1

* 输入

```
abc
```

* 输出

```
3
```

```python
N = str(input())
M = 0
for i in set(N):
    if 0<=ord(i)<=127:
        M += 1
    else:
        continue
print(M)
```



### 字符统计

* 题目描述

如果统计的个数相同，则按照ASCII码由小到大排序输出 。如果有其他字符，则对这些字符不用进行统计。 

实现以下接口：
输入一个字符串，对字符中的各个英文字符，数字，空格进行统计（可反复调用）
按照统计个数由多到少输出统计结果，如果统计的个数相同，则按照ASII码由小到大排序输出
清空目前的统计结果，重新统计
调用者会保证：
输入的字符串以‘\0’结尾。 

* 输入描述:

```
输入一串字符。
```

* 输出描述:

```
对字符中的
各个英文字符（大小写分开统计），数字，空格进行统计，并按照统计个数由多到少输出,如果统计的个数相同，则按照ASII码由小到大排序输出 。如果有其他字符，则对这些字符不用进行统计。
```

示例1

* 输入

```
aadddccddc
```

* 输出

```
dca
```



```python
while True:
    try:
        d = {}
        a = str(input())
        for i in set(a):
            d[i] = a.count(i)
        string = sorted(sorted(d.items(), key=lambda x: x[0]), key = lambda item:item[1], reverse = True)
        str1 = ''.join([_ for (_, __) in string])
        print(str1)
    except:
        break
```

### 挑7

* 题目描述

输出7有关数字的个数，包括7的倍数，还有包含7的数字（如17，27，37...70，71，72，73...）的个数（一组测试用例里可能有多组数据，请注意处理）

* 输入描述:

```
一个正整数N。(N不大于30000)
```

* 输出描述:

```
不大于N的与7有关的数字个数，例如输入20，与7有关的数字包括7,14,17.
```

示例1

* 输入

```
20
```

* 输出

```
3
```

```python
while True:
    try:
        N = int(input())
        i = 0
        while N > 0:
            if N % 7 == 0 or '7' in str(N):
                i += 1
            N -= 1
        print(i)
    except:
        break
```

### 简单错误记录

* 题目描述

开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。

 处理： 

1. 记录最多8条错误记录，循环记录，对相同的错误记录（净文件名称和行号完全匹配）只记录一条，错误计数增加；

2.  超过16个字符的文件名称，只记录文件的最后有效16个字符；

3. 输入的文件可能带路径，记录文件名称不能带路径。

* 输入描述:

```
一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。
```

* 输出描述:

```
将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开，如：
```

示例1

* 输入

```
E:\V1R2\product\fpgadrive.c   1325
```

* 输出

```
fpgadrive.c 1325 1
```

```python
wrong={}
name = []
while True:
    try:
        M = input().split()
        _ = M[0].split('\\')[-1]
        if len(_) > 16:
            _ = _[-16:]
        else:
            pass
        tmp = _ + ' ' + M[-1]
        if tmp in wrong.keys():
            wrong[tmp] += 1
        else:
            wrong[tmp] = 1
            name.append(tmp)
    except:
        break

for i in name[-8:]: # 记录8条记录也就是表示只有最后8个`item`
    print(i + ' ' + str(wrong[i]))

```

### 密码验证合格程序

* 题目描述

密码要求:

1. 长度超过8位

2. 包括大小写字母.数字.其它符号,以上四种至少三种 

3. 不能有相同长度超2的子串重复

说明:长度超过2的子串

* 输入描述:

```
一组或多组长度超过2的子符串。每组占一行
```

* 输出描述:

```
如果符合要求输出：OK，否则输出NG
```

示例1

* 输入

```
021Abc9000
021Abc9Abc1
021ABC9000
021$bc9000
```

* 输出

```
OK
NG
NG
OK
```

```python
def le(s):
    if len(s) > 8:
        return True
    else:
        return False


def rep(s):
    for i in range(len(s)-3):
        if s[i:i+3] in s[i+1:]:
            return False
            break
    return True


def arr(s):
    _ = [0] * 4
    for i in s:
        if i.isupper():
            _[0] = 1
        elif i.islower():
            _[1] = 1
        elif i.isdigit():
            _[2] = 1
        else:
            _[3] = 1
        if sum(_) >=3 :
            return True
            break
    return False


while True:
    try:
        _ = input().strip()
        if le(_) and rep(_) and arr(_):
            print('OK')
        else:
            print('NG')
    except:
        break
```

### 简单密码

* 题目描述

密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。 

假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。 

他是这么变换的，大家都知道手机上的字母： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换， 

__声明__：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。 

* 输入描述:

```
输入包括多个测试数据。输入是一个明文，密码长度不超过100个字符，输入直到文件结尾
```

* 输出描述:

```
输出渊子真正的密文
```

示例1

* 输入

```
YUANzhi1987
```

* 输出

```
zvbo9441987
```

```python
new = ""
while True:
    try:
        m=input()
        for i in m:
            if i.isupper() :
                if i is not 'Z':
                    new+=chr(ord(i.lower())+1)
                elif  i is 'Z':
                    new+='a'
            elif i.islower():
                if i in 'abc':
                    new += '2'
                elif i in 'def':
                    new += '3'
                elif i in 'ghi':
                    new += '4'
                elif i in 'jkl':
                    new += '5'
                elif i in 'mno':
                    new += '6'
                elif i in 'pqrs':
                    new += '7'
                elif i in 'tuv':
                    new += '8'
                elif i in 'wxyz':
                    new += '9'
            elif i.isdigit():
                new+=i
    except:
        break

print(new.strip())
```











## 数字

### 等差数列

* 题目描述

功能:等差数列 2，5，8，11，14。。。。

输入:正整数N >0

输出:求等差数列前N项和

返回:转换成功返回 0 ,非法输入与异常返回-1

* 输入描述:

```
输入一个正整数。
```

* 输出描述:

```
输出一个相加后的整数。
```

示例1

* 输入

```
2
```

* 输出

```
7
```

```python
while True:
    try:
        N = int(input())
        print((3 * (N - 1 ) + 4) * N // 2)
    except:
        break
```

### iNOC 产品部-杨辉三角的变形

* 题目描述

​            1

​         1  1  1

​      1  2  3  2  1

   1  3  6  7  6  3  1

1  4  10 16 19  16 10  4  1

以上三角形的数阵，第一行只有一个数1，以下每行的每个数，是恰好是它上面的数，左上角数到右上角的数，3个数之和（如果不存在某个数，认为该数就是0）。

求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。例如输入3,则输出2，输入4则输出3。

 

输入n(n <= 1000000000)

* 输入描述:

```
输入一个int整数
```

* 输出描述:

```
输出返回的int值
```

示例1

* 输入

```
4
```

* 输出

```
3
```





### 正负均正II

* 题目描述

从输入任意个整型数，统计其中的负数个数并求所有非负数的平均值

* 输入描述:

```
输入任意个整数
```

* 输出描述:

```
输出负数个数以及所有非负数的平均值
```

示例1

* 输入

```
-13
-4
-7
```

* 输出

```
3
0.0
```

```python
while True:
    try:
        N = map(int,input().split())
        c1,c2,c3 = 0, 0, 0
        for i, n in enumerate(N):
            if n < 0:
                c1 += 1
            else:
                c2 += 1
                c3 +=n
        print(int(c1))
        print('%.1f'%(c3/c2))  # Be careful of the output format
    except:
        break
```





### 最小公倍数

* 题目描述

正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。

* 输入描述:

```
输入两个正整数A和B。
```

* 输出描述:

```
输出A和B的最小公倍数。
```

示例1

* 输入

```
5 7
```

* 输出

```
35
```

```python
while True:
    try:
        M,N = map(int,input().split())
        i, j = sorted([M, N])
        m = i % j
        while m !=0:
            i = j
            j = m
            m = i%j
            # `i,j,m = j,m,i%j`  can not be used
        print(M * N // j)
    except:
        break
```





### 质数因子

* 题目描述

功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ） ，**最后一个数后面也要有空格**

详细描述： 

函数接口说明： 

public String getResult(long ulDataInput) 

输入参数： 

long ulDataInput：输入的正整数 

返回值： 

String 

* 输入描述:

```
输入一个long型整数
```

* 输出描述:

```
按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。
```

示例1

* 输入

```
180
```

* 输出

```
2 2 3 3 5
```

```python
N = int(input())
index = [1]
r = 2
while r <= N:
    if N % r == 0:
        index.append(r)
        N = N // r
        continue
    r += 1

for i in index[1:]:
    print(i, end=' ')
```

### 取近似值

* 题目描述

写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 

* 输入描述:

```
输入一个正浮点数值
```

* 输出描述:

```
输出该数值的近似整数值
```

* 示例1

* 输入

```
5.5
```

* 输出

```
6
```

```python
print(round(float(input())+0.001))
```

### 合并表记录

* 题目描述

数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 

* 输入描述:

```
先输入键值对的个数
然后输入成对的index和value值，以空格隔开
```

输出描述:

```
输出合并后的键值对（多行）
```

* 示例1

* 输入

```
4
0 1
0 2
1 2
3 4
```

* 输出

```
0 3
1 2
3 4
```

### 提取不重复数字

* 题目描述

输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。

* 输入描述:

```
输入一个int型整数
```

* 输出描述:

```
按照从右向左的阅读顺序，返回一个不含重复数字的新的整数
```

示例1

* 输入

```
9876673
```

* 输出

```
37689
```

```python
N = str(input())[::-1]
N_ = list(set(N))
N_.sort(key=N.index)
print(''.join(N_))
```



### Redraiment的走法

Redraiment是走梅花桩的高手。Redraiment总是起点不限，从前到后，往高的桩子走，但走的步数最多，不知道为什么？你能替Redraiment研究他最多走的步数吗？ 

样例输入

6

2 5 1 5 4 5

 样例输出

3

 提示

Example: 
6个点的高度各为 2 5 1 5 4 5 
如从第1格开始走,最多为3步, 2 4 5 
从第2格开始走,最多只有1步,5 
而从第3格开始走最多有3步,1 4 5 
从第5格开始走最多有2步,4 5

所以这个结果是3。

接口说明

方法原型：

​    int GetResult(int num, int[] pInput, List  pResult);

输入参数：
   int num：整数，表示数组元素的个数（保证有效）。
   int[] pInput: 数组，存放输入的数字。

输出参数：
   List pResult: 保证传入一个空的List，要求把结果放入第一个位置。
返回值：
  正确返回1，错误返回0

* 输入描述:

```
输入多行，先输入数组的个数，再输入相应个数的整数
```

* 输出描述:

```
输出结果
```

示例1

* 输入

```
6
2
5
1
5
4
5
```

* 输出

```
3
```

```python
import sys
while True:
    try:
        N = sys.stdin.readline().strip()
        M=[int(_) for _ in sys.stdin.readline().strip().split(' ')]
        W = [1]
        for i in range(1,len(M)):
            _ = 1
            for j in range(i):
                if M[i] > M[j]:
                    _ = max(W[j] + 1,_)
            W.append(_)
        print(max(W))
    except:
        break
```







